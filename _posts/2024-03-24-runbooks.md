---
layout: post
title:  "Use variables in runbooks"
date:   2024-03-24 09:38:00 -0600
categories: blog
---

Runbooks are a common documentation format used to instruct people to perform specific tasks.
It is quite common to see instructions such as:

~~~~
kubectl get pod | grep <service-name>  # get the name of the pod
cmd1 -p <pod> -c <container name>      # get id from 3rd column
cmd2 -p <pod> -c <container name> <id> # perform some operation
~~~~

This is a terrible practice!!

The commands in the runbook are typically intended to be copy/pasted
by a human into a shell for execution.  If they are written as
above, the human needs to expend cognitive effort to parse the
ouptut of `get pod` and descover the name of the pod.  They then
need to edit the subsequent commands manually which takes time and
is error-prone.  In addition, if the operator inadvertantly executes
a command before editing, the `<` and `>` symbols become redirect
operators which will probably result in undesirable effects on the
local filesystem and potentially run commands in your production
environment with completely unexpected inputs and unexpected
arguments.  Many runbooks contain commands with multiple pieces
that the user must manually edit, and it is easy to miss a few when
responding during a time-sensitive, high-stress incident.  These
issues can be mitigated by using shell variables directly in the
run book.  For example, the above could be written:

~~~~
container_name=<some-fixed-string>
pod=$(kubectl get pod | awk '/service-name/{print $1}')
id=$(cmd1 -p $pod -c $container_name | awk '{print $3}')
cmd2 -p $pod -c $container_name $id
~~~~

With the above format, the user only needs to make a single edit (filling in
the container name) before copy/pasting the commands into a shell.
Further improvements can be made which make the runbook a bit
ugly to read, but much more robust against copy/paste errors.  For
example:

~~~~
container_name=$(cmd-to-generate-container-name) &&
pod=$(kubectl get pod | awk '/service-name/{print $1}' | grep .) &&
id=$(cmd1 -p "${pod:?}" -c "${container_name:?}" | awk '{print $3}' | grep .) &&
cmd2 -p "${pod:?}" -c "${container_name:?}" "${id?}"
~~~~

This last example is perhaps a bit ugly, but the purpose of code snippets
in the runbook is *not* readable code; its purpose is easy copy/paste.

We should strive to make the code snippet in a run-book copy/pasteable
with zero modification.  The `awk | grep ` pipeline is generally
an anti-pattern, but using `grep` to produce a status code is perhaps
preferrable to generating a return status with `awk`.  You may be
tempted use PIPESTATUS to get the exit status of the prior command,
but this restricts the user to using a shell which supports that,
and it is generally wise to avoid shell specific constructs in your
runbook.  You may like bash, but the person executing the commands
in the runbook may be using zsh, or perhaps they are forced to run
the commands in an environment that only has 1978 version of sh.
A better approach is to fix the tool so that the output of `cmd1`
does not need to be piped to a filter.  (Similarly, you can often
pass flags to `kubectl` so that no post-processing is necessary.)


In short, use shell variables and portable shell syntax in your
runbook code snippet so that an operator can easily copy/paste
the snipped directly into a shell without needing to make modifications.
